"""
This file is generated by the src/mk_pairs_iops.py script.
DO NOT CHANGE THIS FILE DIRECTLY!!!
"""

from ..arithmetic.numbers import Complex, Float, FractionTuple, try_power
from ..utils import NUMBER, TERMS, FACTORS




def return_terms(cls, pairs, new=object.__new__):
    if not pairs:
        return cls.zero
    if len(pairs)==1:
        t, c = pairs.items()[0]
        if c==1:
            return t
        if t==cls.one:
            return cls.convert(c)
    #RETURN_NEW(HEAD=TERMS; DATA=pairs)
    #NEWINSTANCE(OBJ=_tmp2; HEAD=TERMS; DATA=pairs)
    _tmp2 = new(cls)
    _tmp2.head = TERMS
    _tmp2.data = pairs
    return _tmp2

def return_factors(cls, pairs, new=object.__new__):
    if not pairs:
        return cls.one
    elif len(pairs)==1:
        t, c = pairs.items()[0]
        if c==1:
            return t
        if t==cls.one:
            return t
    #RETURN_NEW(HEAD=FACTORS; DATA=pairs)
    #NEWINSTANCE(OBJ=_tmp4; HEAD=FACTORS; DATA=pairs)
    _tmp4 = new(cls)
    _tmp4.head = FACTORS
    _tmp4.data = pairs
    return _tmp4

def inplace_add(cls, obj, pairs, pairs_get, one):
    tobj = type(obj)
    if tobj is cls:
        head = obj.head
        if head is NUMBER:
            value = obj.data
            if value:
                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=one; VALUE=value; SIGN=+)
                _tmp6 = pairs_get(one)
                if _tmp6 is None:
                    pairs[one] = + value
                else:
                    _tmp6 = _tmp6 + value
                    if _tmp6:
                        pairs[one] = _tmp6
                    else:
                        del pairs[one]
        elif head is TERMS:
            for t,c in obj.data.iteritems():
                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=t; VALUE=c; SIGN=+)
                _tmp7 = pairs_get(t)
                if _tmp7 is None:
                    pairs[t] = + c
                else:
                    _tmp7 = _tmp7 + c
                    if _tmp7:
                        pairs[t] = _tmp7
                    else:
                        del pairs[t]
        else:
            #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=obj; VALUE=1; SIGN=+)
            _tmp8 = pairs_get(obj)
            if _tmp8 is None:
                pairs[obj] = + 1
            else:
                _tmp8 = _tmp8 + 1
                if _tmp8:
                    pairs[obj] = _tmp8
                else:
                    del pairs[obj]
    #ELIF_CHECK_NUMBER(T=tobj)
    elif tobj is int or tobj is long or tobj is FractionTuple or tobj is float or tobj is Float or tobj is Complex or tobj is complex:
        if obj:
            #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=one; VALUE=obj; SIGN=+)
            _tmp10 = pairs_get(one)
            if _tmp10 is None:
                pairs[one] = + obj
            else:
                _tmp10 = _tmp10 + obj
                if _tmp10:
                    pairs[one] = _tmp10
                else:
                    del pairs[one]
    else:
        inplace_add(cls, cls.convert(obj), pairs, pairs_get, one)

def inplace_add2(cls, obj, coeff, pairs, pairs_get, one):
    if not coeff:
        return
    tobj = type(obj)
    if tobj is cls:
        head = obj.head
        if head is NUMBER:
            value = coeff * obj.data
            if value:
                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=one; VALUE=value; SIGN=+)
                _tmp11 = pairs_get(one)
                if _tmp11 is None:
                    pairs[one] = + value
                else:
                    _tmp11 = _tmp11 + value
                    if _tmp11:
                        pairs[one] = _tmp11
                    else:
                        del pairs[one]
        elif head is TERMS:
            for t,c in obj.data.iteritems():
                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=t; VALUE=coeff*c; SIGN=+)
                _tmp12 = pairs_get(t)
                if _tmp12 is None:
                    pairs[t] = + coeff*c
                else:
                    _tmp12 = _tmp12 + coeff*c
                    if _tmp12:
                        pairs[t] = _tmp12
                    else:
                        del pairs[t]
        else:
            #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=obj; VALUE=coeff; SIGN=+)
            _tmp13 = pairs_get(obj)
            if _tmp13 is None:
                pairs[obj] = + coeff
            else:
                _tmp13 = _tmp13 + coeff
                if _tmp13:
                    pairs[obj] = _tmp13
                else:
                    del pairs[obj]
    #ELIF_CHECK_NUMBER(T=tobj)
    elif tobj is int or tobj is long or tobj is FractionTuple or tobj is float or tobj is Float or tobj is Complex or tobj is complex:
        value = coeff * obj
        if value:
            #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=one; VALUE=value; SIGN=+)
            _tmp15 = pairs_get(one)
            if _tmp15 is None:
                pairs[one] = + value
            else:
                _tmp15 = _tmp15 + value
                if _tmp15:
                    pairs[one] = _tmp15
                else:
                    del pairs[one]
    else:
        inplace_add2(cls, cls.convert(obj), coeff, pairs, pairs_get, one)

def inplace_sub(cls, obj, pairs, pairs_get, one):
    tobj = type(obj)
    if tobj is cls:
        head = obj.head
        if head is NUMBER:
            value = obj.data
            if value:
                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=one; VALUE=value; SIGN=-)
                _tmp16 = pairs_get(one)
                if _tmp16 is None:
                    pairs[one] = - value
                else:
                    _tmp16 = _tmp16 - value
                    if _tmp16:
                        pairs[one] = _tmp16
                    else:
                        del pairs[one]
        elif HEAD is TERMS:
            for t,c in obj.data.iteritems():
                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=t; VALUE=c; SIGN=-)
                _tmp17 = pairs_get(t)
                if _tmp17 is None:
                    pairs[t] = - c
                else:
                    _tmp17 = _tmp17 - c
                    if _tmp17:
                        pairs[t] = _tmp17
                    else:
                        del pairs[t]
        else:
            #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=obj; VALUE=1; SIGN=-)
            _tmp18 = pairs_get(obj)
            if _tmp18 is None:
                pairs[obj] = - 1
            else:
                _tmp18 = _tmp18 - 1
                if _tmp18:
                    pairs[obj] = _tmp18
                else:
                    del pairs[obj]
    #ELIF_CHECK_NUMBER(T=tobj)
    elif tobj is int or tobj is long or tobj is FractionTuple or tobj is float or tobj is Float or tobj is Complex or tobj is complex:
        if obj:
            #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=one; VALUE=obj; SIGN=-)
            _tmp20 = pairs_get(one)
            if _tmp20 is None:
                pairs[one] = - obj
            else:
                _tmp20 = _tmp20 - obj
                if _tmp20:
                    pairs[one] = _tmp20
                else:
                    del pairs[one]
    else:
        inplace_add(cls, cls.convert(obj), pairs, pairs_get, one)

def inplace_mul(cls, obj, pairs, pairs_get, try_power=try_power, NUMBER=NUMBER):
    tobj = type(obj)
    if tobj is cls:
        head = obj.head
        if head is NUMBER:
            return obj.data
        elif head is TERMS:
            data = obj.data
            if len(data)==1:
                t, number = data.items()[0]
                #MUL_FACTOR_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; FACTOR=t; VALUE=1; SIGN=+; NUMBER=number)
                _tmp21 = pairs_get(t)
                if _tmp21 is None:
                    pairs[t] = + 1
                else:
                    _tmp21 = _tmp21 + 1
                    if type(_tmp21) is cls and _tmp21.head is NUMBER:
                        _tmp21 = _tmp21.data
                    if _tmp21:
                        if t.head is NUMBER:
                            del pairs[t]
                            z, sym = try_power(t.data, _tmp21)
                            if sym:
                                for t1, c1 in sym:
                                    #NEWINSTANCE(OBJ=tt; HEAD=NUMBER; DATA=t1)
                                    tt = new(cls)
                                    tt.head = NUMBER
                                    tt.data = t1
                                    #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=tt; VALUE=c1; SIGN=+)
                                    _tmp23 = pairs_get(tt)
                                    if _tmp23 is None:
                                        pairs[tt] = + c1
                                    else:
                                        _tmp23 = _tmp23 + c1
                                        if _tmp23:
                                            pairs[tt] = _tmp23
                                        else:
                                            del pairs[tt]
                            number = number * z
                            
                        else:
                            pairs[t] = _tmp21
                    else:
                        del pairs[t]
                return number
            number = 1
            #MUL_FACTOR_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; FACTOR=obj; VALUE=1; SIGN=+; NUMBER=number)
            _tmp24 = pairs_get(obj)
            if _tmp24 is None:
                pairs[obj] = + 1
            else:
                _tmp24 = _tmp24 + 1
                if type(_tmp24) is cls and _tmp24.head is NUMBER:
                    _tmp24 = _tmp24.data
                if _tmp24:
                    if obj.head is NUMBER:
                        del pairs[obj]
                        z, sym = try_power(obj.data, _tmp24)
                        if sym:
                            for t1, c1 in sym:
                                #NEWINSTANCE(OBJ=tt; HEAD=NUMBER; DATA=t1)
                                tt = new(cls)
                                tt.head = NUMBER
                                tt.data = t1
                                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=tt; VALUE=c1; SIGN=+)
                                _tmp26 = pairs_get(tt)
                                if _tmp26 is None:
                                    pairs[tt] = + c1
                                else:
                                    _tmp26 = _tmp26 + c1
                                    if _tmp26:
                                        pairs[tt] = _tmp26
                                    else:
                                        del pairs[tt]
                        number = number * z
                        
                    else:
                        pairs[obj] = _tmp24
                else:
                    del pairs[obj]
            return number
        elif head is FACTORS:
            number = 1
            for t, c in obj.data.iteritems():
                #MUL_FACTOR_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; FACTOR=t; VALUE=c; SIGN=+; NUMBER=number)
                _tmp27 = pairs_get(t)
                if _tmp27 is None:
                    pairs[t] = + c
                else:
                    _tmp27 = _tmp27 + c
                    if type(_tmp27) is cls and _tmp27.head is NUMBER:
                        _tmp27 = _tmp27.data
                    if _tmp27:
                        if t.head is NUMBER:
                            del pairs[t]
                            z, sym = try_power(t.data, _tmp27)
                            if sym:
                                for t1, c1 in sym:
                                    #NEWINSTANCE(OBJ=tt; HEAD=NUMBER; DATA=t1)
                                    tt = new(cls)
                                    tt.head = NUMBER
                                    tt.data = t1
                                    #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=tt; VALUE=c1; SIGN=+)
                                    _tmp29 = pairs_get(tt)
                                    if _tmp29 is None:
                                        pairs[tt] = + c1
                                    else:
                                        _tmp29 = _tmp29 + c1
                                        if _tmp29:
                                            pairs[tt] = _tmp29
                                        else:
                                            del pairs[tt]
                            number = number * z
                            
                        else:
                            pairs[t] = _tmp27
                    else:
                        del pairs[t]
            return number
        else:
            number = 1
            #MUL_FACTOR_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; FACTOR=obj; VALUE=1; SIGN=+; NUMBER=number)
            _tmp30 = pairs_get(obj)
            if _tmp30 is None:
                pairs[obj] = + 1
            else:
                _tmp30 = _tmp30 + 1
                if type(_tmp30) is cls and _tmp30.head is NUMBER:
                    _tmp30 = _tmp30.data
                if _tmp30:
                    if obj.head is NUMBER:
                        del pairs[obj]
                        z, sym = try_power(obj.data, _tmp30)
                        if sym:
                            for t1, c1 in sym:
                                #NEWINSTANCE(OBJ=tt; HEAD=NUMBER; DATA=t1)
                                tt = new(cls)
                                tt.head = NUMBER
                                tt.data = t1
                                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=tt; VALUE=c1; SIGN=+)
                                _tmp32 = pairs_get(tt)
                                if _tmp32 is None:
                                    pairs[tt] = + c1
                                else:
                                    _tmp32 = _tmp32 + c1
                                    if _tmp32:
                                        pairs[tt] = _tmp32
                                    else:
                                        del pairs[tt]
                        number = number * z
                        
                    else:
                        pairs[obj] = _tmp30
                else:
                    del pairs[obj]
            return number
    #ELIF_CHECK_NUMBER(T=tobj)
    elif tobj is int or tobj is long or tobj is FractionTuple or tobj is float or tobj is Float or tobj is Complex or tobj is complex:
        return obj
    else:
        return inplace_mul(cls, cls.convert(obj), pairs, pairs_get)

def inplace_mul2(cls, obj, exp, pairs, pairs_get, try_power=try_power, NUMBER=NUMBER):
    if not exp:
        return 1
    tobj = type(obj)
    if tobj is cls:
        head = obj.head
        if head is NUMBER:
            return obj.data ** exp
        elif head is TERMS:
            data = obj.data
            if len(data)==1:
                t, number = data.items()[0]
                #MUL_FACTOR_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; FACTOR=t; VALUE=exp; SIGN=+; NUMBER=number)
                _tmp34 = pairs_get(t)
                if _tmp34 is None:
                    pairs[t] = + exp
                else:
                    _tmp34 = _tmp34 + exp
                    if type(_tmp34) is cls and _tmp34.head is NUMBER:
                        _tmp34 = _tmp34.data
                    if _tmp34:
                        if t.head is NUMBER:
                            del pairs[t]
                            z, sym = try_power(t.data, _tmp34)
                            if sym:
                                for t1, c1 in sym:
                                    #NEWINSTANCE(OBJ=tt; HEAD=NUMBER; DATA=t1)
                                    tt = new(cls)
                                    tt.head = NUMBER
                                    tt.data = t1
                                    #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=tt; VALUE=c1; SIGN=+)
                                    _tmp36 = pairs_get(tt)
                                    if _tmp36 is None:
                                        pairs[tt] = + c1
                                    else:
                                        _tmp36 = _tmp36 + c1
                                        if _tmp36:
                                            pairs[tt] = _tmp36
                                        else:
                                            del pairs[tt]
                            number = number * z
                            
                        else:
                            pairs[t] = _tmp34
                    else:
                        del pairs[t]
                return number
            number = 1
            #MUL_FACTOR_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; FACTOR=obj; VALUE=exp; SIGN=+; NUMBER=number)
            _tmp37 = pairs_get(obj)
            if _tmp37 is None:
                pairs[obj] = + exp
            else:
                _tmp37 = _tmp37 + exp
                if type(_tmp37) is cls and _tmp37.head is NUMBER:
                    _tmp37 = _tmp37.data
                if _tmp37:
                    if obj.head is NUMBER:
                        del pairs[obj]
                        z, sym = try_power(obj.data, _tmp37)
                        if sym:
                            for t1, c1 in sym:
                                #NEWINSTANCE(OBJ=tt; HEAD=NUMBER; DATA=t1)
                                tt = new(cls)
                                tt.head = NUMBER
                                tt.data = t1
                                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=tt; VALUE=c1; SIGN=+)
                                _tmp39 = pairs_get(tt)
                                if _tmp39 is None:
                                    pairs[tt] = + c1
                                else:
                                    _tmp39 = _tmp39 + c1
                                    if _tmp39:
                                        pairs[tt] = _tmp39
                                    else:
                                        del pairs[tt]
                        number = number * z
                        
                    else:
                        pairs[obj] = _tmp37
                else:
                    del pairs[obj]
            return number
        elif head is FACTORS:
            number = 1
            for t, c in obj.data.iteritems():
                #MUL_FACTOR_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; FACTOR=t; VALUE=c*exp; SIGN=+; NUMBER=number)
                _tmp40 = pairs_get(t)
                if _tmp40 is None:
                    pairs[t] = + c*exp
                else:
                    _tmp40 = _tmp40 + c*exp
                    if type(_tmp40) is cls and _tmp40.head is NUMBER:
                        _tmp40 = _tmp40.data
                    if _tmp40:
                        if t.head is NUMBER:
                            del pairs[t]
                            z, sym = try_power(t.data, _tmp40)
                            if sym:
                                for t1, c1 in sym:
                                    #NEWINSTANCE(OBJ=tt; HEAD=NUMBER; DATA=t1)
                                    tt = new(cls)
                                    tt.head = NUMBER
                                    tt.data = t1
                                    #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=tt; VALUE=c1; SIGN=+)
                                    _tmp42 = pairs_get(tt)
                                    if _tmp42 is None:
                                        pairs[tt] = + c1
                                    else:
                                        _tmp42 = _tmp42 + c1
                                        if _tmp42:
                                            pairs[tt] = _tmp42
                                        else:
                                            del pairs[tt]
                            number = number * z
                            
                        else:
                            pairs[t] = _tmp40
                    else:
                        del pairs[t]
            return number
        else:
            number = 1
            #MUL_FACTOR_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; FACTOR=obj; VALUE=exp; SIGN=+; NUMBER=number)
            _tmp43 = pairs_get(obj)
            if _tmp43 is None:
                pairs[obj] = + exp
            else:
                _tmp43 = _tmp43 + exp
                if type(_tmp43) is cls and _tmp43.head is NUMBER:
                    _tmp43 = _tmp43.data
                if _tmp43:
                    if obj.head is NUMBER:
                        del pairs[obj]
                        z, sym = try_power(obj.data, _tmp43)
                        if sym:
                            for t1, c1 in sym:
                                #NEWINSTANCE(OBJ=tt; HEAD=NUMBER; DATA=t1)
                                tt = new(cls)
                                tt.head = NUMBER
                                tt.data = t1
                                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=tt; VALUE=c1; SIGN=+)
                                _tmp45 = pairs_get(tt)
                                if _tmp45 is None:
                                    pairs[tt] = + c1
                                else:
                                    _tmp45 = _tmp45 + c1
                                    if _tmp45:
                                        pairs[tt] = _tmp45
                                    else:
                                        del pairs[tt]
                        number = number * z
                        
                    else:
                        pairs[obj] = _tmp43
                else:
                    del pairs[obj]
            return number
    #ELIF_CHECK_NUMBER(T=tobj)
    elif tobj is int or tobj is long or tobj is FractionTuple or tobj is float or tobj is Float or tobj is Complex or tobj is complex:
        return obj ** exp
    else:
        return inplace_mul2(cls, cls.convert(obj), exp, pairs, pairs_get)

    
