"""
This file is generated by the sympycore/basealgebra/mk_pairs_iops.py script.
DO NOT CHANGE THIS FILE DIRECTLY!!!
"""

from ..arithmetic.numbers import Complex, Float, FractionTuple, try_power
from ..utils import NUMBER, TERMS, FACTORS




def return_terms(cls, pairs, new=object.__new__):
    if not pairs:
        return cls.zero
    if len(pairs)==1:
        t, c = pairs.items()[0]
        if c==1:
            return t
        if t==cls.one:
            return cls.convert(c)
    #RETURN_NEW(HEAD=TERMS; DATA=pairs)
    #NEWINSTANCE(OBJ=_tmp2; HEAD=TERMS; DATA=pairs)
    _tmp2 = new(cls)
    _tmp2.head = TERMS
    _tmp2.data = pairs
    return _tmp2

def return_factors(cls, pairs, new=object.__new__):
    pairs.pop(cls.one, None)
    if not pairs:
        return cls.one
    if len(pairs)==1:
        t, c = pairs.items()[0]
        if c==1:
            return t
        if t==cls.one:
            return t
    #RETURN_NEW(HEAD=FACTORS; DATA=pairs)
    #NEWINSTANCE(OBJ=_tmp4; HEAD=FACTORS; DATA=pairs)
    _tmp4 = new(cls)
    _tmp4.head = FACTORS
    _tmp4.data = pairs
    return _tmp4

def inplace_add(cls, obj, pairs, pairs_get, one):
    tobj = type(obj)
    if tobj is cls:
        head = obj.head
        if head is NUMBER:
            #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=one; VALUE=obj.data; SIGN=+)
            _tmp6 = pairs_get(one)
            if _tmp6 is None:
                pairs[one] = + obj.data
            else:
                _tmp6 = _tmp6 + obj.data
                if _tmp6:
                    pairs[one] = _tmp6
                else:
                    del pairs[one]
        elif head is TERMS:
            for t,c in obj.data.iteritems():
                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=t; VALUE=c; SIGN=+)
                _tmp7 = pairs_get(t)
                if _tmp7 is None:
                    pairs[t] = + c
                else:
                    _tmp7 = _tmp7 + c
                    if _tmp7:
                        pairs[t] = _tmp7
                    else:
                        del pairs[t]
        else:
            #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=obj; VALUE=1; SIGN=+)
            _tmp8 = pairs_get(obj)
            if _tmp8 is None:
                pairs[obj] = + 1
            else:
                _tmp8 = _tmp8 + 1
                if _tmp8:
                    pairs[obj] = _tmp8
                else:
                    del pairs[obj]
    #ELIF_CHECK_NUMBER(T=tobj)
    elif tobj is int or tobj is long or tobj is FractionTuple or tobj is float or tobj is Float or tobj is Complex or tobj is complex:
        #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=one; VALUE=obj; SIGN=+)
        _tmp10 = pairs_get(one)
        if _tmp10 is None:
            pairs[one] = + obj
        else:
            _tmp10 = _tmp10 + obj
            if _tmp10:
                pairs[one] = _tmp10
            else:
                del pairs[one]
    else:
        inplace_add(cls, cls.convert(obj), pairs, pairs_get, one)


def inplace_sub(cls, obj, pairs, pairs_get, one):
    tobj = type(obj)
    if tobj is cls:
        head = obj.head
        if head is NUMBER:
            #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=one; VALUE=obj.data; SIGN=-)
            _tmp11 = pairs_get(one)
            if _tmp11 is None:
                pairs[one] = - obj.data
            else:
                _tmp11 = _tmp11 - obj.data
                if _tmp11:
                    pairs[one] = _tmp11
                else:
                    del pairs[one]
        elif HEAD is TERMS:
            for t,c in obj.data.iteritems():
                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=t; VALUE=c; SIGN=-)
                _tmp12 = pairs_get(t)
                if _tmp12 is None:
                    pairs[t] = - c
                else:
                    _tmp12 = _tmp12 - c
                    if _tmp12:
                        pairs[t] = _tmp12
                    else:
                        del pairs[t]
        else:
            #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=obj; VALUE=1; SIGN=-)
            _tmp13 = pairs_get(obj)
            if _tmp13 is None:
                pairs[obj] = - 1
            else:
                _tmp13 = _tmp13 - 1
                if _tmp13:
                    pairs[obj] = _tmp13
                else:
                    del pairs[obj]
    #ELIF_CHECK_NUMBER(T=tobj)
    elif tobj is int or tobj is long or tobj is FractionTuple or tobj is float or tobj is Float or tobj is Complex or tobj is complex:
        #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=one; VALUE=obj; SIGN=-)
        _tmp15 = pairs_get(one)
        if _tmp15 is None:
            pairs[one] = - obj
        else:
            _tmp15 = _tmp15 - obj
            if _tmp15:
                pairs[one] = _tmp15
            else:
                del pairs[one]
    else:
        inplace_add(cls, cls.convert(obj), pairs, pairs_get, one)

def inplace_mul(cls, obj, pairs, pairs_get):
    tobj = type(obj)
    if tobj is cls:
        head = obj.head
        if head is NUMBER:
            return obj.data
        elif head is TERMS:
            data = obj.data
            if len(data)==1:
                t, number = data.items()[0]
                #MUL_FACTOR_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; FACTOR=t; VALUE=1; SIGN=+; NUMBER=number)
                _tmp16 = pairs_get(t)
                if _tmp16 is None:
                    pairs[t] = + 1
                else:
                    _tmp16 = _tmp16 + 1
                    if type(_tmp16) is cls and _tmp16.head is NUMBER:
                        _tmp16 = _tmp16.data
                    if _tmp16:
                        if t.head is NUMBER:
                            del pairs[t]
                            z, sym = try_power(t.data, _tmp16)
                            if sym:
                                for t1, c1 in sym:
                                    #NEWINSTANCE(OBJ=tt; HEAD=NUMBER; DATA=t1)
                                    tt = new(cls)
                                    tt.head = NUMBER
                                    tt.data = t1
                                    #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=tt; VALUE=c1; SIGN=+)
                                    _tmp18 = pairs_get(tt)
                                    if _tmp18 is None:
                                        pairs[tt] = + c1
                                    else:
                                        _tmp18 = _tmp18 + c1
                                        if _tmp18:
                                            pairs[tt] = _tmp18
                                        else:
                                            del pairs[tt]
                            number = number * z
                            
                        else:
                            pairs[t] = _tmp16
                    else:
                        del pairs[t]
                return number
            number = 1
            #MUL_FACTOR_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; FACTOR=obj; VALUE=1; SIGN=+; NUMBER=number)
            _tmp19 = pairs_get(obj)
            if _tmp19 is None:
                pairs[obj] = + 1
            else:
                _tmp19 = _tmp19 + 1
                if type(_tmp19) is cls and _tmp19.head is NUMBER:
                    _tmp19 = _tmp19.data
                if _tmp19:
                    if obj.head is NUMBER:
                        del pairs[obj]
                        z, sym = try_power(obj.data, _tmp19)
                        if sym:
                            for t1, c1 in sym:
                                #NEWINSTANCE(OBJ=tt; HEAD=NUMBER; DATA=t1)
                                tt = new(cls)
                                tt.head = NUMBER
                                tt.data = t1
                                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=tt; VALUE=c1; SIGN=+)
                                _tmp21 = pairs_get(tt)
                                if _tmp21 is None:
                                    pairs[tt] = + c1
                                else:
                                    _tmp21 = _tmp21 + c1
                                    if _tmp21:
                                        pairs[tt] = _tmp21
                                    else:
                                        del pairs[tt]
                        number = number * z
                        
                    else:
                        pairs[obj] = _tmp19
                else:
                    del pairs[obj]
            return number
        elif head is FACTORS:
            number = 1
            for t, c in obj.data.iteritems():
                #MUL_FACTOR_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; FACTOR=t; VALUE=c; SIGN=+; NUMBER=number)
                _tmp22 = pairs_get(t)
                if _tmp22 is None:
                    pairs[t] = + c
                else:
                    _tmp22 = _tmp22 + c
                    if type(_tmp22) is cls and _tmp22.head is NUMBER:
                        _tmp22 = _tmp22.data
                    if _tmp22:
                        if t.head is NUMBER:
                            del pairs[t]
                            z, sym = try_power(t.data, _tmp22)
                            if sym:
                                for t1, c1 in sym:
                                    #NEWINSTANCE(OBJ=tt; HEAD=NUMBER; DATA=t1)
                                    tt = new(cls)
                                    tt.head = NUMBER
                                    tt.data = t1
                                    #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=tt; VALUE=c1; SIGN=+)
                                    _tmp24 = pairs_get(tt)
                                    if _tmp24 is None:
                                        pairs[tt] = + c1
                                    else:
                                        _tmp24 = _tmp24 + c1
                                        if _tmp24:
                                            pairs[tt] = _tmp24
                                        else:
                                            del pairs[tt]
                            number = number * z
                            
                        else:
                            pairs[t] = _tmp22
                    else:
                        del pairs[t]
            return number
        else:
            number = 1
            #MUL_FACTOR_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; FACTOR=obj; VALUE=1; SIGN=+; NUMBER=number)
            _tmp25 = pairs_get(obj)
            if _tmp25 is None:
                pairs[obj] = + 1
            else:
                _tmp25 = _tmp25 + 1
                if type(_tmp25) is cls and _tmp25.head is NUMBER:
                    _tmp25 = _tmp25.data
                if _tmp25:
                    if obj.head is NUMBER:
                        del pairs[obj]
                        z, sym = try_power(obj.data, _tmp25)
                        if sym:
                            for t1, c1 in sym:
                                #NEWINSTANCE(OBJ=tt; HEAD=NUMBER; DATA=t1)
                                tt = new(cls)
                                tt.head = NUMBER
                                tt.data = t1
                                #ADD_TERM_VALUE_DICT(DICT=pairs; DICT_GET=pairs_get; TERM=tt; VALUE=c1; SIGN=+)
                                _tmp27 = pairs_get(tt)
                                if _tmp27 is None:
                                    pairs[tt] = + c1
                                else:
                                    _tmp27 = _tmp27 + c1
                                    if _tmp27:
                                        pairs[tt] = _tmp27
                                    else:
                                        del pairs[tt]
                        number = number * z
                        
                    else:
                        pairs[obj] = _tmp25
                else:
                    del pairs[obj]
            return number
    #ELIF_CHECK_NUMBER(T=tobj)
    elif tobj is int or tobj is long or tobj is FractionTuple or tobj is float or tobj is Float or tobj is Complex or tobj is complex:
        return obj
    else:
        return inplace_mul(cls, cls.convert(obj), pairs, pairs_get)
    
