"""
This file is generated by the sympycore/arithmetic/mk_methods.py script.
DO NOT CHANGE THIS FILE DIRECTLY!!!
"""

from .numbers import Complex, Float, FractionTuple, div




def complex_add(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_REAL(T=t)
    if t is int or t is long or t is FractionTuple or t is float or t is Float:
        #ADD_COMPLEX_REAL(LHS=self; RHS=other)
        #RETURN_COMPLEX(REAL=self.real + other; IMAG=self.imag)
        _tmp4 = new(cls)
        _tmp4.real = self.real + other
        _tmp4.imag = self.imag
        return _tmp4
    #IF_CHECK_COMPLEX(T=t)
    if t is cls or t is complex:
        #ADD_COMPLEX_COMPLEX(LHS=self; RHS=other)
        #RETURN_COMPLEX2(REAL=self.real + other.real; IMAG=self.imag + other.imag)
        _tmp7 = self.imag + other.imag
        if not _tmp7:
            return self.real + other.real
        #RETURN_COMPLEX(REAL=self.real + other.real; IMAG=_tmp7)
        _tmp8 = new(cls)
        _tmp8.real = self.real + other.real
        _tmp8.imag = _tmp7
        return _tmp8
    return NotImplemented

def complex_sub(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_REAL(T=t)
    if t is int or t is long or t is FractionTuple or t is float or t is Float:
        #SUB_COMPLEX_REAL(LHS=self; RHS=other)
        #RETURN_COMPLEX(REAL=self.real - other; IMAG=self.imag)
        _tmp11 = new(cls)
        _tmp11.real = self.real - other
        _tmp11.imag = self.imag
        return _tmp11
    #IF_CHECK_COMPLEX(T=t)
    if t is cls or t is complex:
        #SUB_COMPLEX_COMPLEX(LHS=self; RHS=other)
        #RETURN_COMPLEX2(REAL=self.real - other.real; IMAG=self.imag - other.imag)
        _tmp14 = self.imag - other.imag
        if not _tmp14:
            return self.real - other.real
        #RETURN_COMPLEX(REAL=self.real - other.real; IMAG=_tmp14)
        _tmp15 = new(cls)
        _tmp15.real = self.real - other.real
        _tmp15.imag = _tmp14
        return _tmp15
    return NotImplemented

def complex_rsub(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_REAL(T=t)
    if t is int or t is long or t is FractionTuple or t is float or t is Float:
        #SUB_REAL_COMPLEX(LHS=other; RHS=self)
        #RETURN_COMPLEX(REAL=other - self.real; IMAG=-self.imag)
        _tmp18 = new(cls)
        _tmp18.real = other - self.real
        _tmp18.imag = -self.imag
        return _tmp18
    if t is complex:
        #SUB_COMPLEX_COMPLEX(LHS=other; RHS=self)
        #RETURN_COMPLEX2(REAL=other.real - self.real; IMAG=other.imag - self.imag)
        _tmp20 = other.imag - self.imag
        if not _tmp20:
            return other.real - self.real
        #RETURN_COMPLEX(REAL=other.real - self.real; IMAG=_tmp20)
        _tmp21 = new(cls)
        _tmp21.real = other.real - self.real
        _tmp21.imag = _tmp20
        return _tmp21
    return NotImplemented

def complex_mul(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_REAL(T=t)
    if t is int or t is long or t is FractionTuple or t is float or t is Float:
        #MUL_COMPLEX_REAL(LHS=self; RHS=other)
        #RETURN_COMPLEX(REAL=self.real*other; IMAG=self.imag*other)
        _tmp24 = new(cls)
        _tmp24.real = self.real*other
        _tmp24.imag = self.imag*other
        return _tmp24
    #IF_CHECK_COMPLEX(T=t)
    if t is cls or t is complex:
        #MUL_COMPLEX_COMPLEX(LHS=self; RHS=other)
        a, b = self.real, self.imag
        c, d = other.real, other.imag
        #RETURN_COMPLEX2(REAL=a*c-b*d; IMAG=b*c+a*d)
        _tmp27 = b*c+a*d
        if not _tmp27:
            return a*c-b*d
        #RETURN_COMPLEX(REAL=a*c-b*d; IMAG=_tmp27)
        _tmp28 = new(cls)
        _tmp28.real = a*c-b*d
        _tmp28.imag = _tmp27
        return _tmp28
    return NotImplemented

def complex_div(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_REAL(T=t)
    if t is int or t is long or t is FractionTuple or t is float or t is Float:
        #DIV_COMPLEX_REAL(LHS=self; RHS=other)
        #RETURN_COMPLEX(REAL=div(self.real,other); IMAG=div(self.imag,other))
        _tmp31 = new(cls)
        _tmp31.real = div(self.real,other)
        _tmp31.imag = div(self.imag,other)
        return _tmp31
    #IF_CHECK_COMPLEX(T=t)
    if t is cls or t is complex:
        #DIV_COMPLEX_COMPLEX(LHS=self; RHS=other)
        a, b = self.real, self.imag
        c, d = other.real, other.imag
        mag = c*c + d*d
        im = b*c-a*d
        re = div(a*c+b*d, mag)
        if not im:
            return re
        im = div(im, mag)
        #RETURN_COMPLEX(REAL=re; IMAG=im)
        _tmp34 = new(cls)
        _tmp34.real = re
        _tmp34.imag = im
        return _tmp34
    return NotImplemented

def complex_rdiv(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_REAL(T=t)
    if t is int or t is long or t is FractionTuple or t is float or t is Float:
        #DIV_REAL_COMPLEX(LHS=other; RHS=self)
        _tmp36 = other
        c, d = self.real, self.imag
        mag = c*c + d*d
        im = div(-_tmp36*d, mag)
        re = div(_tmp36*c, mag)
        #RETURN_COMPLEX(REAL=re; IMAG=im)
        _tmp37 = new(cls)
        _tmp37.real = re
        _tmp37.imag = im
        return _tmp37
    if t is complex:
        #DIV_COMPLEX_COMPLEX(LHS=other; RHS=self)
        a, b = other.real, other.imag
        c, d = self.real, self.imag
        mag = c*c + d*d
        im = b*c-a*d
        re = div(a*c+b*d, mag)
        if not im:
            return re
        im = div(im, mag)
        #RETURN_COMPLEX(REAL=re; IMAG=im)
        _tmp39 = new(cls)
        _tmp39.real = re
        _tmp39.imag = im
        return _tmp39
    return NotImplemented

def complex_pow(self, other, m=None, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_INT(T=t)
    if t is int or t is long:
        if not other:
            return 1
        if other==1:
            return self
        if other==2:
            return self*self
        if other < 0:
            base, exponent = 1/self, -other
        else:
            base, exponent = self, other
        #POW_COMPLEX_INT(LHS=base; RHS=exponent)
        a, b = base.real, base.imag
        n = exponent
        if not a:
            case = n % 4
            if not case:
                return b**n
            elif case == 1:
                #RETURN_COMPLEX(REAL=0; IMAG=b**n)
                _tmp42 = new(cls)
                _tmp42.real = 0
                _tmp42.imag = b**n
                return _tmp42
            elif case == 2:
                return -(b**n)
            else:
                #RETURN_COMPLEX(REAL=0; IMAG=-b**n)
                _tmp43 = new(cls)
                _tmp43.real = 0
                _tmp43.imag = -b**n
                return _tmp43
        ta, tb = type(a), type(b)
        m = 1
        if ta is FractionTuple:
            if tb is FractionTuple:
                m = (a[1] * b[1]) ** n
                a, b = a[0]*b[1], a[1]*b[0]
            #ELIF_CHECK_INT(T=tb)
            elif tb is int or tb is long:
                m = a[1] ** n
                a, b = a[0], a[1]*b
        elif tb is FractionTuple:
            #IF_CHECK_INT(T=ta)
            if ta is int or ta is long:
                m = b[1] ** n
                a, b = a*b[1], b[0]
        c, d = 1, 0
        while n:
            if n & 1:
                c, d = a*c-b*d, b*c+a*d
                n -= 1
            a, b = a*a-b*b, 2*a*b
            n //= 2
        if m==1:
            #RETURN_COMPLEX2(REAL=c; IMAG=d)
            _tmp46 = d
            if not _tmp46:
                return c
            #RETURN_COMPLEX(REAL=c; IMAG=_tmp46)
            _tmp47 = new(cls)
            _tmp47.real = c
            _tmp47.imag = _tmp46
            return _tmp47
        if d:
            #RETURN_COMPLEX(REAL=div(c, m); IMAG=div(d, m))
            _tmp48 = new(cls)
            _tmp48.real = div(c, m)
            _tmp48.imag = div(d, m)
            return _tmp48
        return div(c, m)
    return NotImplemented
    
