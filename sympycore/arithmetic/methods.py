"""
This file is generated by the sympycore/arithmetic/mk_methods.py script.
DO NOT CHANGE THIS FILE DIRECTLY!!!
"""

from .numbers import Complex, Float, FractionTuple




def fraction_add(self, other, cls=FractionTuple):
    t = type(other)
    #IF_CHECK_INT(T=t)
    if t is int or t is long:
        #ADD_FRACTION_INT(LHS=self; RHS=other)
        p, q = self
        #RETURN_FRACTION(NUMER=p+q*(other); DENOM=q)
        return cls((p+q*(other), q))
    elif t is cls:
        #ADD_FRACTION_FRACTION(LHS=self; RHS=other)
        #ADDOP_FRACTION_FRACTION(LHS=self; RHS=other; SIGN=+; MOD=%)
        p, q = self
        r, s = other
        _tmp6 = p*s + q*r
        if not _tmp6:
            return 0
        #RETURN_FRACTION2(NUMER=_tmp6; DENOM=q*s; MOD=%)
        #FRACTION_NORMALIZE(NUMER=_tmp6; DENOM=q*s; RNUMER=_p; RDENOM=_q; MOD=%)
        _p = _x = _tmp6
        _q = _y = q*s
        while _y:
            _x, _y = _y, _x % _y
        if _x != 1:
            _p //= _x
            _q //= _x
        if _q == 1:
            return _p
        #RETURN_FRACTION(NUMER=_p; DENOM=_q)
        return cls((_p, _q))
    return NotImplemented

def fraction_sub(self, other, cls=FractionTuple):
    t = type(other)
    #IF_CHECK_INT(T=t)
    if t is int or t is long:
        #SUB_FRACTION_INT(LHS=self; RHS=other)
        p, q = self
        #RETURN_FRACTION(NUMER=p-q*(other); DENOM=q)
        return cls((p-q*(other), q))
    elif t is cls:
        #SUB_FRACTION_FRACTION(LHS=self; RHS=other)
        #ADDOP_FRACTION_FRACTION(LHS=self; RHS=other; SIGN=-; MOD=%)
        p, q = self
        r, s = other
        _tmp14 = p*s - q*r
        if not _tmp14:
            return 0
        #RETURN_FRACTION2(NUMER=_tmp14; DENOM=q*s; MOD=%)
        #FRACTION_NORMALIZE(NUMER=_tmp14; DENOM=q*s; RNUMER=_p; RDENOM=_q; MOD=%)
        _p = _x = _tmp14
        _q = _y = q*s
        while _y:
            _x, _y = _y, _x % _y
        if _x != 1:
            _p //= _x
            _q //= _x
        if _q == 1:
            return _p
        #RETURN_FRACTION(NUMER=_p; DENOM=_q)
        return cls((_p, _q))
    return NotImplemented

def fraction_rsub(self, other, cls=FractionTuple):
    t = type(other)
    #IF_CHECK_INT(T=t)
    if t is int or t is long:
        #SUB_INT_FRACTION(RHS=self; LHS=other)
        p, q = self
        #RETURN_FRACTION(NUMER=q*(other) - p; DENOM=q)
        return cls((q*(other) - p, q))
    return NotImplemented

def complex_add(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_REAL(T=t)
    if t is int or t is long or t is FractionTuple or t is float or t is Float:
        #ADD_COMPLEX_REAL(LHS=self; RHS=other)
        #RETURN_COMPLEX(REAL=self.real + other; IMAG=self.imag)
        _tmp23 = new(cls)
        _tmp23.real = self.real + other
        _tmp23.imag = self.imag
        return _tmp23
    #IF_CHECK_COMPLEX(T=t)
    if t is cls or t is complex:
        #ADD_COMPLEX_COMPLEX(LHS=self; RHS=other)
        #RETURN_COMPLEX2(REAL=self.real + other.real; IMAG=self.imag + other.imag)
        _tmp26 = self.imag + other.imag
        if not _tmp26:
            return self.real + other.real
        #RETURN_COMPLEX(REAL=self.real + other.real; IMAG=_tmp26)
        _tmp27 = new(cls)
        _tmp27.real = self.real + other.real
        _tmp27.imag = _tmp26
        return _tmp27
    return NotImplemented

def complex_sub(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_REAL(T=t)
    if t is int or t is long or t is FractionTuple or t is float or t is Float:
        #SUB_COMPLEX_REAL(LHS=self; RHS=other)
        #RETURN_COMPLEX(REAL=self.real - other; IMAG=self.imag)
        _tmp30 = new(cls)
        _tmp30.real = self.real - other
        _tmp30.imag = self.imag
        return _tmp30
    #IF_CHECK_COMPLEX(T=t)
    if t is cls or t is complex:
        #SUB_COMPLEX_COMPLEX(LHS=self; RHS=other)
        #RETURN_COMPLEX2(REAL=self.real - other.real; IMAG=self.imag - other.imag)
        _tmp33 = self.imag - other.imag
        if not _tmp33:
            return self.real - other.real
        #RETURN_COMPLEX(REAL=self.real - other.real; IMAG=_tmp33)
        _tmp34 = new(cls)
        _tmp34.real = self.real - other.real
        _tmp34.imag = _tmp33
        return _tmp34
    return NotImplemented

def complex_rsub(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_REAL(T=t)
    if t is int or t is long or t is FractionTuple or t is float or t is Float:
        #SUB_REAL_COMPLEX(LHS=other; RHS=self)
        #RETURN_COMPLEX(REAL=other - self.real; IMAG=-self.imag)
        _tmp37 = new(cls)
        _tmp37.real = other - self.real
        _tmp37.imag = -self.imag
        return _tmp37
    if t is complex:
        #SUB_COMPLEX_COMPLEX(LHS=other; RHS=self)
        #RETURN_COMPLEX2(REAL=other.real - self.real; IMAG=other.imag - self.imag)
        _tmp39 = other.imag - self.imag
        if not _tmp39:
            return other.real - self.real
        #RETURN_COMPLEX(REAL=other.real - self.real; IMAG=_tmp39)
        _tmp40 = new(cls)
        _tmp40.real = other.real - self.real
        _tmp40.imag = _tmp39
        return _tmp40
    return NotImplemented

def complex_mul(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_REAL(T=t)
    if t is int or t is long or t is FractionTuple or t is float or t is Float:
        #MUL_COMPLEX_REAL(LHS=self; RHS=other)
        #RETURN_COMPLEX(REAL=self.real*other; IMAG=self.imag*other)
        _tmp43 = new(cls)
        _tmp43.real = self.real*other
        _tmp43.imag = self.imag*other
        return _tmp43
    #IF_CHECK_COMPLEX(T=t)
    if t is cls or t is complex:
        #MUL_COMPLEX_COMPLEX(LHS=self; RHS=other)
        a, b = self.real, self.imag
        c, d = other.real, other.imag
        #RETURN_COMPLEX2(REAL=a*c-b*d; IMAG=b*c+a*d)
        _tmp46 = b*c+a*d
        if not _tmp46:
            return a*c-b*d
        #RETURN_COMPLEX(REAL=a*c-b*d; IMAG=_tmp46)
        _tmp47 = new(cls)
        _tmp47.real = a*c-b*d
        _tmp47.imag = _tmp46
        return _tmp47
    return NotImplemented

def complex_div(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_REAL(T=t)
    if t is int or t is long or t is FractionTuple or t is float or t is Float:
        #DIV_COMPLEX_REAL(LHS=self; RHS=other; MOD=%)
        #DIV_VALUE_VALUE(LHS=self.real; RHS=other; RESULT=re; MOD=%)
        _p, _q = self.real, other
        if not _q:
            raise ZeroDivisionError(repr(self.real) + " / " + repr(other))
        _tp = type(_p)
        #IF_CHECK_INT(T=_tp)
        if _tp is int or _tp is long:
            _tq = type(_q)
            #IF_CHECK_INT(T=_tq)
            if _tq is int or _tq is long:
                #FRACTION_NORMALIZE(NUMER=_p; DENOM=_q; RNUMER=_rp; RDENOM=_rq; MOD=%)
                _rp = _x = _p
                _rq = _y = _q
                while _y:
                    _x, _y = _y, _x % _y
                if _x != 1:
                    _rp //= _x
                    _rq //= _x
                if _rq == 1:
                    re = _rp
                else:
                    re = FractionTuple((_rp, _rq))
            else:
                re = _p / _q
        else:
            re = _p / _q
        #DIV_VALUE_VALUE(LHS=self.imag; RHS=other; RESULT=im; MOD=%)
        _p, _q = self.imag, other
        if not _q:
            raise ZeroDivisionError(repr(self.imag) + " / " + repr(other))
        _tp = type(_p)
        #IF_CHECK_INT(T=_tp)
        if _tp is int or _tp is long:
            _tq = type(_q)
            #IF_CHECK_INT(T=_tq)
            if _tq is int or _tq is long:
                #FRACTION_NORMALIZE(NUMER=_p; DENOM=_q; RNUMER=_rp; RDENOM=_rq; MOD=%)
                _rp = _x = _p
                _rq = _y = _q
                while _y:
                    _x, _y = _y, _x % _y
                if _x != 1:
                    _rp //= _x
                    _rq //= _x
                if _rq == 1:
                    im = _rp
                else:
                    im = FractionTuple((_rp, _rq))
            else:
                im = _p / _q
        else:
            im = _p / _q
        #RETURN_COMPLEX(REAL=re; IMAG=im)
        _tmp58 = new(cls)
        _tmp58.real = re
        _tmp58.imag = im
        return _tmp58
    #IF_CHECK_COMPLEX(T=t)
    if t is cls or t is complex:
        #DIV_COMPLEX_COMPLEX(LHS=self; RHS=other; MOD=%)
        a, b = self.real, self.imag
        c, d = other.real, other.imag
        mag = c*c + d*d
        _tmp60 = b*c-a*d
        #DIV_VALUE_VALUE(LHS=a*c+b*d; RHS=mag; RESULT=re; MOD=%)
        _p, _q = a*c+b*d, mag
        if not _q:
            raise ZeroDivisionError(repr(a*c+b*d) + " / " + repr(mag))
        _tp = type(_p)
        #IF_CHECK_INT(T=_tp)
        if _tp is int or _tp is long:
            _tq = type(_q)
            #IF_CHECK_INT(T=_tq)
            if _tq is int or _tq is long:
                #FRACTION_NORMALIZE(NUMER=_p; DENOM=_q; RNUMER=_rp; RDENOM=_rq; MOD=%)
                _rp = _x = _p
                _rq = _y = _q
                while _y:
                    _x, _y = _y, _x % _y
                if _x != 1:
                    _rp //= _x
                    _rq //= _x
                if _rq == 1:
                    re = _rp
                else:
                    re = FractionTuple((_rp, _rq))
            else:
                re = _p / _q
        else:
            re = _p / _q
        if not _tmp60:
            return re
        #DIV_VALUE_VALUE(LHS=_tmp60; RHS=mag; RESULT=im; MOD=%)
        _p, _q = _tmp60, mag
        if not _q:
            raise ZeroDivisionError(repr(_tmp60) + " / " + repr(mag))
        _tp = type(_p)
        #IF_CHECK_INT(T=_tp)
        if _tp is int or _tp is long:
            _tq = type(_q)
            #IF_CHECK_INT(T=_tq)
            if _tq is int or _tq is long:
                #FRACTION_NORMALIZE(NUMER=_p; DENOM=_q; RNUMER=_rp; RDENOM=_rq; MOD=%)
                _rp = _x = _p
                _rq = _y = _q
                while _y:
                    _x, _y = _y, _x % _y
                if _x != 1:
                    _rp //= _x
                    _rq //= _x
                if _rq == 1:
                    im = _rp
                else:
                    im = FractionTuple((_rp, _rq))
            else:
                im = _p / _q
        else:
            im = _p / _q
        #RETURN_COMPLEX(REAL=re; IMAG=im)
        _tmp69 = new(cls)
        _tmp69.real = re
        _tmp69.imag = im
        return _tmp69
    return NotImplemented

def complex_rdiv(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_REAL(T=t)
    if t is int or t is long or t is FractionTuple or t is float or t is Float:
        #DIV_REAL_COMPLEX(LHS=other; RHS=self; MOD=%)
        _tmp71 = other
        c, d = self.real, self.imag
        mag = c*c + d*d
        #DIV_VALUE_VALUE(LHS=-_tmp71*d; RHS=mag; RESULT=im; MOD=%)
        _p, _q = -_tmp71*d, mag
        if not _q:
            raise ZeroDivisionError(repr(-_tmp71*d) + " / " + repr(mag))
        _tp = type(_p)
        #IF_CHECK_INT(T=_tp)
        if _tp is int or _tp is long:
            _tq = type(_q)
            #IF_CHECK_INT(T=_tq)
            if _tq is int or _tq is long:
                #FRACTION_NORMALIZE(NUMER=_p; DENOM=_q; RNUMER=_rp; RDENOM=_rq; MOD=%)
                _rp = _x = _p
                _rq = _y = _q
                while _y:
                    _x, _y = _y, _x % _y
                if _x != 1:
                    _rp //= _x
                    _rq //= _x
                if _rq == 1:
                    im = _rp
                else:
                    im = FractionTuple((_rp, _rq))
            else:
                im = _p / _q
        else:
            im = _p / _q
        #DIV_VALUE_VALUE(LHS= _tmp71*c; RHS=mag; RESULT=re; MOD=%)
        _p, _q = _tmp71*c, mag
        if not _q:
            raise ZeroDivisionError(repr(_tmp71*c) + " / " + repr(mag))
        _tp = type(_p)
        #IF_CHECK_INT(T=_tp)
        if _tp is int or _tp is long:
            _tq = type(_q)
            #IF_CHECK_INT(T=_tq)
            if _tq is int or _tq is long:
                #FRACTION_NORMALIZE(NUMER=_p; DENOM=_q; RNUMER=_rp; RDENOM=_rq; MOD=%)
                _rp = _x = _p
                _rq = _y = _q
                while _y:
                    _x, _y = _y, _x % _y
                if _x != 1:
                    _rp //= _x
                    _rq //= _x
                if _rq == 1:
                    re = _rp
                else:
                    re = FractionTuple((_rp, _rq))
            else:
                re = _p / _q
        else:
            re = _p / _q
        #RETURN_COMPLEX(REAL=re; IMAG=im)
        _tmp80 = new(cls)
        _tmp80.real = re
        _tmp80.imag = im
        return _tmp80
    if t is complex:
        #DIV_COMPLEX_COMPLEX(LHS=other; RHS=self; MOD=%)
        a, b = other.real, other.imag
        c, d = self.real, self.imag
        mag = c*c + d*d
        _tmp81 = b*c-a*d
        #DIV_VALUE_VALUE(LHS=a*c+b*d; RHS=mag; RESULT=re; MOD=%)
        _p, _q = a*c+b*d, mag
        if not _q:
            raise ZeroDivisionError(repr(a*c+b*d) + " / " + repr(mag))
        _tp = type(_p)
        #IF_CHECK_INT(T=_tp)
        if _tp is int or _tp is long:
            _tq = type(_q)
            #IF_CHECK_INT(T=_tq)
            if _tq is int or _tq is long:
                #FRACTION_NORMALIZE(NUMER=_p; DENOM=_q; RNUMER=_rp; RDENOM=_rq; MOD=%)
                _rp = _x = _p
                _rq = _y = _q
                while _y:
                    _x, _y = _y, _x % _y
                if _x != 1:
                    _rp //= _x
                    _rq //= _x
                if _rq == 1:
                    re = _rp
                else:
                    re = FractionTuple((_rp, _rq))
            else:
                re = _p / _q
        else:
            re = _p / _q
        if not _tmp81:
            return re
        #DIV_VALUE_VALUE(LHS=_tmp81; RHS=mag; RESULT=im; MOD=%)
        _p, _q = _tmp81, mag
        if not _q:
            raise ZeroDivisionError(repr(_tmp81) + " / " + repr(mag))
        _tp = type(_p)
        #IF_CHECK_INT(T=_tp)
        if _tp is int or _tp is long:
            _tq = type(_q)
            #IF_CHECK_INT(T=_tq)
            if _tq is int or _tq is long:
                #FRACTION_NORMALIZE(NUMER=_p; DENOM=_q; RNUMER=_rp; RDENOM=_rq; MOD=%)
                _rp = _x = _p
                _rq = _y = _q
                while _y:
                    _x, _y = _y, _x % _y
                if _x != 1:
                    _rp //= _x
                    _rq //= _x
                if _rq == 1:
                    im = _rp
                else:
                    im = FractionTuple((_rp, _rq))
            else:
                im = _p / _q
        else:
            im = _p / _q
        #RETURN_COMPLEX(REAL=re; IMAG=im)
        _tmp90 = new(cls)
        _tmp90.real = re
        _tmp90.imag = im
        return _tmp90
    return NotImplemented

def complex_pow(self, other, m=None, new=object.__new__, cls=Complex):
    t = type(other)
    #IF_CHECK_INT(T=t)
    if t is int or t is long:
        if not other:
            return 1
        if other==1:
            return self
        if other==2:
            return self*self
        if other < 0:
            base, exponent = 1/self, -other
        else:
            base, exponent = self, other
        #POW_COMPLEX_INT(LHS=base; RHS=exponent; MOD=%)
        a, b = base.real, base.imag
        n = exponent
        if not a:
            case = n % 4
            if not case:
                return b**n
            elif case == 1:
                #RETURN_COMPLEX(REAL=0; IMAG=b**n)
                _tmp93 = new(cls)
                _tmp93.real = 0
                _tmp93.imag = b**n
                return _tmp93
            elif case == 2:
                return -(b**n)
            else:
                #RETURN_COMPLEX(REAL=0; IMAG=-b**n)
                _tmp94 = new(cls)
                _tmp94.real = 0
                _tmp94.imag = -b**n
                return _tmp94
        ta, tb = type(a), type(b)
        m = 1
        if ta is FractionTuple:
            if tb is FractionTuple:
                m = (a[1] * b[1]) ** n
                a, b = a[0]*b[1], a[1]*b[0]
            #ELIF_CHECK_INT(T=tb)
            elif tb is int or tb is long:
                m = a[1] ** n
                a, b = a[0], a[1]*b
        elif tb is FractionTuple:
            #IF_CHECK_INT(T=ta)
            if ta is int or ta is long:
                m = b[1] ** n
                a, b = a*b[1], b[0]
        c, d = 1, 0
        while n:
            if n & 1:
                c, d = a*c-b*d, b*c+a*d
                n -= 1
            a, b = a*a-b*b, 2*a*b
            n //= 2
        if m==1:
            #RETURN_COMPLEX2(REAL=c; IMAG=d)
            _tmp97 = d
            if not _tmp97:
                return c
            #RETURN_COMPLEX(REAL=c; IMAG=_tmp97)
            _tmp98 = new(cls)
            _tmp98.real = c
            _tmp98.imag = _tmp97
            return _tmp98
        if d:
            print c,d,m
            #DIV_VALUE_VALUE(LHS=c; RHS=m; RESULT=re; MOD=%)
            _p, _q = c, m
            if not _q:
                raise ZeroDivisionError(repr(c) + " / " + repr(m))
            _tp = type(_p)
            #IF_CHECK_INT(T=_tp)
            if _tp is int or _tp is long:
                _tq = type(_q)
                #IF_CHECK_INT(T=_tq)
                if _tq is int or _tq is long:
                    #FRACTION_NORMALIZE(NUMER=_p; DENOM=_q; RNUMER=_rp; RDENOM=_rq; MOD=%)
                    _rp = _x = _p
                    _rq = _y = _q
                    while _y:
                        _x, _y = _y, _x % _y
                    if _x != 1:
                        _rp //= _x
                        _rq //= _x
                    if _rq == 1:
                        re = _rp
                    else:
                        re = FractionTuple((_rp, _rq))
                else:
                    re = _p / _q
            else:
                re = _p / _q
            #DIV_VALUE_VALUE(LHS=d; RHS=m; RESULT=im; MOD=%)
            _p, _q = d, m
            if not _q:
                raise ZeroDivisionError(repr(d) + " / " + repr(m))
            _tp = type(_p)
            #IF_CHECK_INT(T=_tp)
            if _tp is int or _tp is long:
                _tq = type(_q)
                #IF_CHECK_INT(T=_tq)
                if _tq is int or _tq is long:
                    #FRACTION_NORMALIZE(NUMER=_p; DENOM=_q; RNUMER=_rp; RDENOM=_rq; MOD=%)
                    _rp = _x = _p
                    _rq = _y = _q
                    while _y:
                        _x, _y = _y, _x % _y
                    if _x != 1:
                        _rp //= _x
                        _rq //= _x
                    if _rq == 1:
                        im = _rp
                    else:
                        im = FractionTuple((_rp, _rq))
                else:
                    im = _p / _q
            else:
                im = _p / _q
            #RETURN_COMPLEX(REAL=re; IMAG=im)
            _tmp107 = new(cls)
            _tmp107.real = re
            _tmp107.imag = im
            return _tmp107
        #DIV_VALUE_VALUE(LHS=c; RHS=m; RESULT=_tmp92; MOD=%)
        _p, _q = c, m
        if not _q:
            raise ZeroDivisionError(repr(c) + " / " + repr(m))
        _tp = type(_p)
        #IF_CHECK_INT(T=_tp)
        if _tp is int or _tp is long:
            _tq = type(_q)
            #IF_CHECK_INT(T=_tq)
            if _tq is int or _tq is long:
                #FRACTION_NORMALIZE(NUMER=_p; DENOM=_q; RNUMER=_rp; RDENOM=_rq; MOD=%)
                _rp = _x = _p
                _rq = _y = _q
                while _y:
                    _x, _y = _y, _x % _y
                if _x != 1:
                    _rp //= _x
                    _rq //= _x
                if _rq == 1:
                    _tmp92 = _rp
                else:
                    _tmp92 = FractionTuple((_rp, _rq))
            else:
                _tmp92 = _p / _q
        else:
            _tmp92 = _p / _q
        return _tmp92
    return NotImplemented
    
