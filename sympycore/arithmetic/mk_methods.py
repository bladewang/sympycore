#!/usr/bin/env python
#
# Created by Pearu Peterson in Febuary 2008
#

import os

def preprocess(source, tmp_cache=[1]):
    result = []
    for line in source.splitlines():
        if line.lstrip().startswith('@'):
            prefix, rest = line.split('@',1)
            i = rest.index('(')
            name = rest[:i]
            tmp_cache[0] += 1
            d = {'TMP':'_tmp%s' % (tmp_cache[0])}
            for arg in rest.strip()[i+1:-1].split(';'):
                if not arg:
                    continue
                key, value = arg.split('=',1)
                d[key.strip()] = value.strip()
            try:
                templ = eval(name, globals(), {})
            except NameError, msg:
                templ = '@' + rest
                print 'NameError: %s (while processing %r)' % (msg, line.strip())
            else:
                if '@' in templ:
                    templ = preprocess(templ)
            result.append(prefix + '#' + rest)
            try:
                templ_d = templ % d
            except Exception, msg:
                print '%s (while processing %r)' % (msg, line.lstrip())
                print d, `templ`
                continue
            for l in templ_d.splitlines():
                result.append(prefix + l)
        else:
            result.append(line)
    return '\n'.join(result)

cwd = os.path.abspath(os.path.dirname(__file__))
targetfile_py = os.path.join(cwd,'methods.py')

template = '''\
"""
This file is generated by the sympycore/arithmetic/mk_methods.py script.
DO NOT CHANGE THIS FILE DIRECTLY!!!
"""

from .numbers import Complex, Float, FractionTuple, div

'''

IF_CHECK_INT = 'if %(T)s is int or %(T)s is long:'
ELIF_CHECK_INT = 'elif %(T)s is int or %(T)s is long:'
IF_CHECK_REAL = 'if %(T)s is int or %(T)s is long or %(T)s is FractionTuple or %(T)s is float or %(T)s is Float:'
IF_CHECK_COMPLEX = 'if %(T)s is cls or %(T)s is complex:'

RETURN_COMPLEX = '''\
%(TMP)s = new(cls)
%(TMP)s.real = %(REAL)s
%(TMP)s.imag = %(IMAG)s
return %(TMP)s
'''

RETURN_COMPLEX2 = '''\
%(TMP)s = %(IMAG)s
if not %(TMP)s:
    return %(REAL)s
@RETURN_COMPLEX(REAL=%(REAL)s; IMAG=%(TMP)s)
'''

ADD_COMPLEX_REAL = '@RETURN_COMPLEX(REAL=%(LHS)s.real + %(RHS)s; IMAG=%(LHS)s.imag)\n'
ADD_COMPLEX_COMPLEX = '@RETURN_COMPLEX2(REAL=%(LHS)s.real + %(RHS)s.real; IMAG=%(LHS)s.imag + %(RHS)s.imag)\n'

SUB_COMPLEX_REAL = '@RETURN_COMPLEX(REAL=%(LHS)s.real - %(RHS)s; IMAG=%(LHS)s.imag)\n'
SUB_COMPLEX_COMPLEX = '@RETURN_COMPLEX2(REAL=%(LHS)s.real - %(RHS)s.real; IMAG=%(LHS)s.imag - %(RHS)s.imag)\n'
SUB_REAL_COMPLEX = '@RETURN_COMPLEX(REAL=%(LHS)s - %(RHS)s.real; IMAG=-%(RHS)s.imag)\n'

MUL_COMPLEX_REAL = '@RETURN_COMPLEX(REAL=%(LHS)s.real*%(RHS)s; IMAG=%(LHS)s.imag*%(RHS)s)\n'
MUL_COMPLEX_COMPLEX = '''\
a, b = %(LHS)s.real, %(LHS)s.imag
c, d = %(RHS)s.real, %(RHS)s.imag
@RETURN_COMPLEX2(REAL=a*c-b*d; IMAG=b*c+a*d)
'''
DIV_COMPLEX_REAL = '@RETURN_COMPLEX(REAL=div(%(LHS)s.real,%(RHS)s); IMAG=div(%(LHS)s.imag,%(RHS)s))\n'
DIV_COMPLEX_COMPLEX = '''\
a, b = %(LHS)s.real, %(LHS)s.imag
c, d = %(RHS)s.real, %(RHS)s.imag
mag = c*c + d*d
im = b*c-a*d
re = div(a*c+b*d, mag)
if not im:
    return re
im = div(im, mag)
@RETURN_COMPLEX(REAL=re; IMAG=im)
'''
DIV_REAL_COMPLEX = '''\
%(TMP)s = %(LHS)s
c, d = %(RHS)s.real, %(RHS)s.imag
mag = c*c + d*d
im = div(-%(TMP)s*d, mag)
re = div(%(TMP)s*c, mag)
@RETURN_COMPLEX(REAL=re; IMAG=im)
'''

POW_COMPLEX_INT = '''\
a, b = %(LHS)s.real, %(LHS)s.imag
n = %(RHS)s
if not a:
    case = n %% 4
    if not case:
        return b**n
    elif case == 1:
        @RETURN_COMPLEX(REAL=0; IMAG=b**n)
    elif case == 2:
        return -(b**n)
    else:
        @RETURN_COMPLEX(REAL=0; IMAG=-b**n)
ta, tb = type(a), type(b)
m = 1
if ta is FractionTuple:
    if tb is FractionTuple:
        m = (a[1] * b[1]) ** n
        a, b = a[0]*b[1], a[1]*b[0]
    @ELIF_CHECK_INT(T=tb)
        m = a[1] ** n
        a, b = a[0], a[1]*b
elif tb is FractionTuple:
    @IF_CHECK_INT(T=ta)
        m = b[1] ** n
        a, b = a*b[1], b[0]
c, d = 1, 0
while n:
    if n & 1:
        c, d = a*c-b*d, b*c+a*d
        n -= 1
    a, b = a*a-b*b, 2*a*b
    n //= 2
if m==1:
    @RETURN_COMPLEX2(REAL=c; IMAG=d)
if d:
    @RETURN_COMPLEX(REAL=div(c, m); IMAG=div(d, m))
return div(c, m)
'''

def main():
    f = open(targetfile_py, 'w')
    print >> f, template
    print >> f, preprocess('''

def complex_add(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    @IF_CHECK_REAL(T=t)
        @ADD_COMPLEX_REAL(LHS=self; RHS=other)
    @IF_CHECK_COMPLEX(T=t)
        @ADD_COMPLEX_COMPLEX(LHS=self; RHS=other)
    return NotImplemented

def complex_sub(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    @IF_CHECK_REAL(T=t)
        @SUB_COMPLEX_REAL(LHS=self; RHS=other)
    @IF_CHECK_COMPLEX(T=t)
        @SUB_COMPLEX_COMPLEX(LHS=self; RHS=other)
    return NotImplemented

def complex_rsub(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    @IF_CHECK_REAL(T=t)
        @SUB_REAL_COMPLEX(LHS=other; RHS=self)
    if t is complex:
        @SUB_COMPLEX_COMPLEX(LHS=other; RHS=self)
    return NotImplemented

def complex_mul(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    @IF_CHECK_REAL(T=t)
        @MUL_COMPLEX_REAL(LHS=self; RHS=other)
    @IF_CHECK_COMPLEX(T=t)
        @MUL_COMPLEX_COMPLEX(LHS=self; RHS=other)
    return NotImplemented

def complex_div(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    @IF_CHECK_REAL(T=t)
        @DIV_COMPLEX_REAL(LHS=self; RHS=other)
    @IF_CHECK_COMPLEX(T=t)
        @DIV_COMPLEX_COMPLEX(LHS=self; RHS=other)
    return NotImplemented

def complex_rdiv(self, other, new=object.__new__, cls=Complex):
    t = type(other)
    @IF_CHECK_REAL(T=t)
        @DIV_REAL_COMPLEX(LHS=other; RHS=self)
    if t is complex:
        @DIV_COMPLEX_COMPLEX(LHS=other; RHS=self)
    return NotImplemented

def complex_pow(self, other, m=None, new=object.__new__, cls=Complex):
    t = type(other)
    @IF_CHECK_INT(T=t)
        if not other:
            return 1
        if other==1:
            return self
        if other==2:
            return self*self
        if other < 0:
            base, exponent = 1/self, -other
        else:
            base, exponent = self, other
        @POW_COMPLEX_INT(LHS=base; RHS=exponent)
    return NotImplemented
    ''')

    f.close()


if __name__=='__main__':
    main()
